# Виправлення помилки 413 та проблем з TTS
**Дата:** 15 жовтня 2025  
**Автор:** Cascade AI  
**Статус:** Виправлено

## Проблеми

### 1. Помилка 413 Payload Too Large
**Симптоми:**
- При виконанні MCP workflow з'являється помилка `Request failed with status code 413`
- Помилка виникає на етапі планування інструментів (Stage 2.1) та верифікації (Stage 2.3)
- Нагромадження контексту до 8000+ токенів

**Причина:**
У функціях `planTools()` та `verifyItem()` передається весь контекст попередніх items з повними `execution_results`, які містять тисячі символів тексту з `playwright_get_visible_text`. Кожен наступний item отримує ВСІ дані з попередніх items, що призводить до експоненційного зростання розміру запиту.

**Приклад проблеми:**
```javascript
// Рядок 483 у mcp-todo-manager.js (ДО виправлення)
Previous items: ${JSON.stringify(todo.items.slice(0, item.id - 1).map(i => ({ 
  id: i.id, 
  action: i.action, 
  status: i.status 
})), null, 2)}
```
Проблема: execution_results НЕ включаються в summary, але вони є в items і можуть містити ВЕСЬ текст сторінки.

### 2. TTS не чути
**Симптоми:**
- Backend успішно відправляє TTS повідомлення через WebSocket
- Frontend отримує повідомлення але аудіо не відтворюється
- Відсутня чітка діагностика де саме виникає проблема

**Причина:**
- Backend відправляє тільки текст для TTS через WebSocket (`agent_message`)
- Frontend має сам синтезувати аудіо через запит до TTS API (localhost:3003)
- Відсутні діагностичні логи для відстеження процесу синтезу та відтворення

## Виправлення

### 1. Виправлення помилки 413

#### Файл: `orchestrator/workflow/mcp-todo-manager.js`

**1.1. Truncate execution_results у planTools() (рядки 480-515)**
```javascript
// FIXED 15.10.2025 - Truncate execution_results to prevent 413 errors
const previousItemsSummary = todo.items.slice(0, item.id - 1).map(i => {
    const summary = { 
        id: i.id, 
        action: i.action, 
        status: i.status 
    };
    
    // Include truncated execution_results if available
    if (i.execution_results && i.execution_results.results) {
        summary.results_summary = i.execution_results.results.map(r => {
            const truncated = { tool: r.tool, success: r.success };
            // Truncate content/text to 200 chars max
            if (r.content && typeof r.content === 'string') {
                truncated.content = r.content.substring(0, 200) + (r.content.length > 200 ? '...[truncated]' : '');
            }
            if (r.text && typeof r.text === 'string') {
                truncated.text = r.text.substring(0, 200) + (r.text.length > 200 ? '...[truncated]' : '');
            }
            if (r.error) {
                truncated.error = typeof r.error === 'string' ? r.error.substring(0, 100) : 'error';
            }
            return truncated;
        });
    }
    
    return summary;
});

const userMessage = `
TODO Item: ${item.action}
Available MCP Tools: ${JSON.stringify(toolsSummary, null, 2)}
Previous items: ${JSON.stringify(previousItemsSummary, null, 2)}

Визнач які інструменти потрібні та параметри для виконання.
`;
```

**Результат:**
- execution_results.content обрізається з ~5000 символів до 200 символів
- execution_results.text обрізається з ~5000 символів до 200 символів  
- execution_results.error обрізається до 100 символів
- Зменшення розміру запиту на ~95%

**1.2. Зменшення truncate ліміту у verifyItem() (рядки 694-714)**
```javascript
// FIXED 14.10.2025 - Truncate long content to avoid token limits
// FIXED 14.10.2025 - Also truncate error messages and stacks to avoid JSON parsing issues
// FIXED 15.10.2025 - Reduce truncate limit from 1000 to 300 to prevent 413 errors
const truncatedResults = execution.results.map(result => {
    const truncated = { ...result };
    if (truncated.content && typeof truncated.content === 'string' && truncated.content.length > 300) {
        truncated.content = truncated.content.substring(0, 300) + '... [truncated]';
    }
    if (truncated.text && typeof truncated.text === 'string' && truncated.text.length > 300) {
        truncated.text = truncated.text.substring(0, 300) + '... [truncated]';
    }
    // НОВИНКА 14.10.2025 - Truncate error messages to avoid JSON parsing issues
    // FIXED 15.10.2025 - Reduce from 500 to 200
    if (truncated.error && typeof truncated.error === 'string' && truncated.error.length > 200) {
        truncated.error = truncated.error.substring(0, 200) + '... [truncated]';
    }
    if (truncated.stack && typeof truncated.stack === 'string' && truncated.stack.length > 200) {
        truncated.stack = truncated.stack.substring(0, 200) + '... [truncated]';
    }
    return truncated;
});
```

**Результат:**
- Зменшення ліміту з 1000 до 300 символів для content/text
- Зменшення ліміту з 500 до 200 символів для error/stack
- Запобігання передачі великих обсягів тексту в verification запит

### 2. Діагностика TTS

#### Файл: `web/static/js/modules/tts-manager.js`

**2.1. Додано діагностичні логи у synthesize() (рядки 184-250)**
```javascript
async synthesize(text, voice = TTS_CONFIG.defaultVoice, options = {}) {
    // FIXED 15.10.2025 - Add diagnostic logging for TTS issues
    this.logger.info(`[TTS-DIAG] synthesize() called: enabled=${this.enabled}, voice=${voice}, text_length=${text?.length || 0}`);
    
    if (!this.enabled) {
        this.logger.error('[TTS-DIAG] TTS service not available, throwing error');
        throw new Error('TTS service not available');
    }
    // ... решта коду
    
    this.logger.info(`[TTS-DIAG] Sending TTS request to server: text="${processedText.substring(0, 50)}...", voice=${voice}`);
    // ... запит до API
    
    this.logger.info(`[TTS-DIAG] Received audio blob: size=${data?.size || 'unknown'} bytes, type=${data?.type || 'unknown'}`);
}
```

**2.2. Додано діагностичні логи у playAudio() (рядки 286-301)**
```javascript
async playAudio(audioBlob, agent = 'atlas') {
    // FIXED 15.10.2025 - Add diagnostic logging
    this.logger.info(`[TTS-DIAG] playAudio() called: agent=${agent}, blob_size=${audioBlob?.size || 'unknown'}, blob_type=${audioBlob?.type || 'unknown'}`);
    
    const audioUrl = URL.createObjectURL(audioBlob);
    this.logger.info(`[TTS-DIAG] Created audio URL: ${audioUrl}`);
    // ... решта коду
}
```

#### Файл: `web/static/js/modules/chat-manager.js`

**2.3. Додано діагностичні логи у handleAgentMessage() (рядок 469)**
```javascript
async handleAgentMessage(messageData) {
    const { content, agent, ttsContent, voice, messageId, mode, ttsOptimized } = messageData;

    // FIXED 15.10.2025 - Add diagnostic logging for TTS debugging
    this.logger.info(`[TTS-DIAG] handleAgentMessage: agent=${agent}, has_ttsContent=${!!ttsContent}, has_content=${!!content}, ttsContent_length=${ttsContent?.length || 0}, content_length=${content?.length || 0}, voice=${voice || 'undefined'}, mode=${mode || 'undefined'}`);
    // ... решта коду
}
```

## Тестування

### Перевірка виправлення 413

1. **Запустити систему:**
```bash
cd /Users/dev/Documents/GitHub/atlas4
./restart_system.sh
```

2. **Виконати завдання що раніше викликало помилку:**
```
на робочому столі створи гарну пропозицію з фото у вигляді презентації з найкращими ціни в Укараїні на BYD song plus 2025 року на 10 автомобілів по зростанню з найкращою ціною.
```

3. **Перевірити логи:**
```bash
tail -f /Users/dev/Documents/GitHub/atlas4/logs/orchestrator.log | grep -E "(413|Planning tools|Verifying item)"
```

**Очікуваний результат:**
- Відсутність помилок 413
- Успішне планування та виконання всіх items
- Розмір запитів до LLM не перевищує 2000-3000 токенів

### Перевірка TTS діагностики

1. **Відкрити консоль браузера** (F12)

2. **Виконати будь-яке завдання** що має відповідь від агента

3. **Перевірити логи в консолі:**
```
[TTS-DIAG] handleAgentMessage: agent=atlas, has_ttsContent=true, ...
[TTS-DIAG] synthesize() called: enabled=true, voice=mykyta, ...
[TTS-DIAG] Sending TTS request to server: text="...", voice=mykyta
[TTS-DIAG] Received audio blob: size=45123 bytes, type=audio/wav
[TTS-DIAG] playAudio() called: agent=atlas, blob_size=45123, ...
[TTS-DIAG] Created audio URL: blob:http://localhost:5000/...
```

**Можливі проблеми та рішення:**

| Проблема | Лог | Рішення |
|----------|-----|---------|
| TTS сервіс недоступний | `TTS service not available` | Перевірити чи запущено TTS на localhost:3003 |
| Помилка синтезу | `TTS synthesis failed` | Перевірити логи TTS сервісу |
| Помилка відтворення | `Audio play failed` | Перевірити autoplay дозволи браузера |
| Відсутній blob | `blob_size=unknown` | Проблема з TTS API response |

## Очікувані покращення

### Продуктивність
- ✅ Зменшення розміру API запитів на ~95%
- ✅ Запобігання помилкам 413 при роботі з великими обсягами даних
- ✅ Швидше виконання планування та верифікації (менше даних для обробки)

### Діагностика
- ✅ Чіткі логи на кожному етапі TTS процесу
- ✅ Можливість визначити точне місце проблеми (backend/frontend/browser)
- ✅ Інформація про розмір та тип audio blob для debugging

## Наступні кроки

1. **Тестування на реальних сценаріях** з великими обсягами даних
2. **Моніторинг логів TTS** для виявлення проблем з синтезом
3. **Додаткова оптимізація** truncate лімітів якщо потрібно
4. **Виправлення TTS API** якщо діагностика покаже проблеми на backend

## Файли змінено

1. `/orchestrator/workflow/mcp-todo-manager.js` - виправлення 413
2. `/web/static/js/modules/tts-manager.js` - діагностика TTS
3. `/web/static/js/modules/chat-manager.js` - діагностика TTS

## Примітки

- Truncate ліміти можуть бути налаштовані в залежності від потреб
- Діагностичні логи можуть бути видалені після вирішення проблеми TTS
- Рекомендується моніторити розмір запитів до LLM API

---
**Останнє оновлення:** 15.10.2025 00:23 UTC+3
